---
title: "FixedReduced2_SimulationStudy"
author: "Syed Rafey Abbas"
date: "2024-07-17"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, include=FALSE}
#packages 
library(lme4)
library(MASS)
library(parallel)
library(ggplot2)
library(tidyr)
library(dplyr)
library(patchwork)
```


```{r}
# Defining the BIC functions, looking at three definitions 
bic_fitzmaurice <- function(model) {
  logLik_val <- as.numeric(logLik(model))
  n_params <- length(fixef(model)) + sum(sapply(VarCorr(model), function(x) prod(dim(x))))
  N <- length(unique(model@frame$group_id)) # Number of subjects
  BIC_value <- -2 * logLik_val + log(N) * n_params
  return(BIC_value)
}

bic_normal <- function(model) {
  logLik_val <- as.numeric(logLik(model))
  n_params <- length(fixef(model)) + sum(sapply(VarCorr(model), function(x) prod(dim(x))))
  N <- nrow(model@frame) # Total number of observations
  BIC_value <- -2 * logLik_val + log(N) * n_params
  return(BIC_value)
}

bic_hybrid <- function(model) {
  logLik_val <- as.numeric(logLik(model))
  n_fixed <- length(fixef(model))
  n_random <- sum(sapply(VarCorr(model), function(x) prod(dim(x))))
  N <- nrow(model@frame) # Total number of observations
  m <- length(unique(model@frame$group_id)) # Number of groups
  BIC_value <- -2 * logLik_val + n_fixed * log(N) + n_random * log(m)
  return(BIC_value)
}
```


```{r}
# Data generation function
generate_data <- function(ni, m, beta, random_effects_var) {
  group_id <- rep(1:m, each = ni)
  time <- rep(1:ni, times = m)
  x1 <- rnorm(ni * m)
  x2 <- rnorm(ni * m)
  x3 <- rnorm(ni * m)
  epsilon <- rnorm(ni * m)
  
  # Generate random effects
  random_intercepts <- rnorm(m, mean = 0, sd = sqrt(random_effects_var[1]))
  random_slopes <- rnorm(m, mean = 0, sd = sqrt(random_effects_var[2]))
  
  # Assign random effects to each group
  random_intercept <- rep(random_intercepts, each = ni)
  random_slope <- rep(random_slopes, each = ni) * time 
  
  # Generate response variable y
  y <- beta[1] * x1 + beta[2] * x2 + beta[3] * x3 + random_intercept + random_slope + epsilon
  
  data <- data.frame(y = y, x1 = x1, x2 = x2, x3 = x3, time = time, group_id = factor(group_id))
  return(data)
}

# Model fitting function
fit_models <- function(data) {
  models <- list(
    full = lmer(y ~ x1 + x2 + x3 + (1 + time + I(time^2) | group_id), data = data),
    reduced1 = lmer(y ~ x1 + x2 + x3 + (1 | group_id), data = data),
    reduced2 = lmer(y ~ x1 + x2 + x3 + (1 + time | group_id), data = data)
  )
  return(models)
}

# BIC calculation function
calculate_bic <- function(models, bic_func) {
  bic_values <- sapply(models, bic_func)
  return(bic_values)
}

# Simulate and fit models
simulate_and_fit_models <- function(ni, m, beta, random_effects_var, i) {
  message("Starting simulation ", i)
  data <- generate_data(ni, m, beta, random_effects_var)
  models <- fit_models(data)
  
  bic_fitzmaurice_values <- calculate_bic(models, bic_fitzmaurice)
  bic_normal_values <- calculate_bic(models, bic_normal)
  bic_hybrid_values <- calculate_bic(models, bic_hybrid)
  
  selected_model_fitzmaurice <- names(which.min(bic_fitzmaurice_values))
  selected_model_normal <- names(which.min(bic_normal_values))
  selected_model_hybrid <- names(which.min(bic_hybrid_values))
  
  results_df <- data.frame(
    simulation = i,
    ni = ni,
    bic_fitzmaurice_full = bic_fitzmaurice_values["full"],
    bic_fitzmaurice_reduced1 = bic_fitzmaurice_values["reduced1"],
    bic_fitzmaurice_reduced2 = bic_fitzmaurice_values["reduced2"],
    bic_normal_full = bic_normal_values["full"],
    bic_normal_reduced1 = bic_normal_values["reduced1"],
    bic_normal_reduced2 = bic_normal_values["reduced2"],
    bic_hybrid_full = bic_hybrid_values["full"],
    bic_hybrid_reduced1 = bic_hybrid_values["reduced1"],
    bic_hybrid_reduced2 = bic_hybrid_values["reduced2"],
    selected_model_fitzmaurice = selected_model_fitzmaurice,
    correct_model_fitzmaurice = selected_model_fitzmaurice == "reduced2",
    selected_model_normal = selected_model_normal,
    correct_model_normal = selected_model_normal == "reduced2",
    selected_model_hybrid = selected_model_hybrid,
    correct_model_hybrid = selected_model_hybrid == "reduced2"
  )
  
  message("Ending simulation ", i)
  return(results_df)
}

```

```{r}
# Function to run multiple simulations
run_simulation <- function(num_simulations, ni, m, beta, random_effects_var, ncores = detectCores()) {
  cat("Running simulations...\n")
  results <- mclapply(1:num_simulations, function(i) {
    simulate_and_fit_models(ni, m, beta, random_effects_var, i)
  }, mc.cores = ncores)
  
  return(do.call(rbind, results))
}

# Modified function to run simulations for different subject numbers
run_simulations_for_subject_numbers <- function(subject_numbers, num_simulations, m, beta, random_effects_var, ncores = detectCores()) {
  results_list <- list()
  
  for (ni in subject_numbers) {
    cat(sprintf("\nRunning simulations for subject number ni = %d...\n", ni))
    results <- run_simulation(num_simulations, ni, m, beta, random_effects_var, ncores = ncores)
    results <- na.omit(results)
    results_list[[paste0("ni_", ni)]] <- results
  }
  
  return(results_list)
}

```



```{r, eval=FALSE}
# Parameters for the simulation
set.seed(123)
num_simulations <- 100
m <- 30
beta <- c(1, 1, 1)
random_effects_var <- c(1, 0.5)
subject_numbers <- c(10, 30, 50)

# Run simulations and save results
results <- run_simulations_for_subject_numbers(subject_numbers, num_simulations, m, beta, random_effects_var, ncores = 1) # defined ncores because mclapply does not work on Windows
saveRDS(results, file = "simulation_results_list.rds")


```

```{r, fig.height=8}
results_list <- readRDS("simulation_results_list.rds")

# Initialize lists to store plots
violin_plots <- list()
bar_plots <- list()

for (name in names(results_list)) {
  all_results <- results_list[[name]]
  
  # Convert BIC columns to long format for plotting
  bics_long <- pivot_longer(all_results, cols = starts_with("bic_"), names_to = "BIC_definition", values_to = "BIC")
  
  # Convert selected model columns to long format for plotting
  selected_models_long <- pivot_longer(all_results, cols = starts_with("selected_model_"), 
                                       names_to = "BIC_definition", values_to = "selected_model")
  
  # Violin plot for BIC values
  violin_plot <- ggplot(bics_long, aes(x = model_name, y = BIC)) +
    geom_violin() +
    facet_wrap(~ BIC_definition) +
    theme_minimal() +
    labs(title = paste("BIC Distribution by True Model and Fitted Model -", name),
         x = "Model", y = "BIC Value") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.margin = margin(0, 0, 0, 0))
  
  violin_plots[[name]] <- violin_plot
  
  # Bar plot for selected models
  bar_plot <- ggplot(selected_models_long, aes(x = BIC_definition, fill = selected_model)) +
    geom_bar(position = "fill", width = 1) +  # Make sure bars are adjacent
    facet_wrap(~ BIC_definition) +
    theme_minimal() +
    labs(title = paste("Model Selection Proportions by True Model -", name),
         x = "True Model", y = "Proportion",
         fill = "Selected Model") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.margin = margin(0, 0, 0, 0))
  
  bar_plots[[name]] <- bar_plot
  
  # Print summary
  summary_table <- selected_models_long %>%
    group_by(BIC_definition, true_model, selected_model) %>%
    summarise(count = n(), .groups = 'drop') %>%
    pivot_wider(names_from = selected_model, values_from = count, values_fill = list(count = 0))
  
  print(paste("Summary for", name))
  print(summary_table)
}

# Combine all violin plots using patchwork
combined_violin_plot <- wrap_plots(violin_plots, ncol = 1) & theme(plot.margin = margin(0, 0, 0, 0))
combined_bar_plot <- wrap_plots(bar_plots, ncol = 1) & theme(plot.margin = margin(0, 0, 0, 0))

# Display combined plots
print(combined_violin_plot)
#print(combined_bar_plot)

```


```{r}
all_results <- results_list %>% bind_rows(.id = "ni")
row.names(all_results) <- NULL

selected_models_long <- pivot_longer(all_results, 
                                     cols =starts_with("selected_model_"), names_to = "BIC_definition", values_to = "selected_model") %>% 
  mutate(BIC_definition = factor(BIC_definition, 
                                 levels = c("selected_model_fitzmaurice", "selected_model_normal", "selected_model_hybrid"), 
                                 labels = c("BIC_f", "BIC_s","BIC_h")))

ggplot(selected_models_long, aes(x = BIC_definition, fill = selected_model)) +
    geom_bar() +  
    facet_wrap(~ ni) +
    theme_minimal() +
    labs(title = "Model Selection Proportions",
         x = "", y = "Proportion",
         fill = "Selected Model")

```

