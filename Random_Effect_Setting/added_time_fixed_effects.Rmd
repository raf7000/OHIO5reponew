---
title: "FixedReduced2_SimulationStudy"
author: "Syed Rafey Abbas"
date: "2024-07-17"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, include=FALSE}
#packages 
library(lme4)
library(MASS)
library(parallel)
library(ggplot2)
library(tidyr)
library(dplyr)
library(patchwork)
```


```{r}
# Defining the BIC functions, looking at three definitions 
bic_fitzmaurice <- function(model) {
  logLik_val <- as.numeric(logLik(model))
  n_params <- length(fixef(model)) + sum(sapply(VarCorr(model), function(x) prod(dim(x)))) + 1 
  N <- length(unique(model@frame$group_id)) # Number of subjects
  BIC_value <- -2 * logLik_val + log(N) * n_params
  return(BIC_value)
}

bic_normal <- function(model) {
  logLik_val <- as.numeric(logLik(model))
  n_params <- length(fixef(model)) + sum(sapply(VarCorr(model), function(x) prod(dim(x)))) + 1 #residual standard deviation parameter
  N <- nrow(model@frame) # Total number of observations
  BIC_value <- -2 * logLik_val + log(N) * n_params
  return(BIC_value)
}

bic_hybrid <- function(model) {
  logLik_val <- as.numeric(logLik(model))
  n_fixed <- length(fixef(model))
  n_random <- sum(sapply(VarCorr(model), function(x) prod(dim(x))))
  N <- nrow(model@frame) # Total number of observations
  m <- length(unique(model@frame$group_id)) # Number of groups
  BIC_value <- -2 * logLik_val + n_fixed * log(N) + n_random * log(m)
  return(BIC_value)
}
```


```{r}
# Data generation function
generate_data <- function(ni, m, beta, random_effects_var) {
  group_id <- rep(1:m, each = ni)
  time <- rep(1:ni, times = m)
  x1 <- rnorm(ni * m)
  x2 <- rnorm(ni * m)
  x3 <- rnorm(ni * m)
  epsilon <- rnorm(ni * m, sd = 5)
  
  # Generate random effects
  random_intercepts <- rnorm(m, mean = 0, sd = sqrt(random_effects_var[1]))
  random_slopes <- rnorm(m, mean = 0, sd = sqrt(random_effects_var[2]))
  
  # Assign random effects to each group
  random_intercept <- rep(random_intercepts, each = ni)
  random_slope <- rep(random_slopes, each = ni) * time 
  
  # Generate response variable y
  y <- beta[1] * time + beta[2] * I(time^2) + beta[3] * x1 + beta[4] * x2 + beta[5] * x3 + random_intercept + random_slope + epsilon
  
  data <- data.frame(y = as.numeric(y), x1 = x1, x2 = x2, x3 = x3, time = time, group_id = factor(group_id))
  return(data)
}

# Model fitting function
fit_models <- function(data) {
  models <- list(
    full = lmer(y ~ 0+time + I(time^2) + x1 + x2 + x3  + (1 + time + I(time^2) || group_id), data = data, REML = FALSE),
    reduced1 = lmer(y ~ 0+time + I(time^2) + x1 + x2 + x3  + (1 | group_id), data = data, REML = FALSE),
    reduced2 = lmer(y ~ 0+time + I(time^2) + x1 + x2 + x3  + (1 + time || group_id), data = data, REML = FALSE)
  )
  return(models)
}

# BIC calculation function
calculate_bic <- function(models, bic_func) {
  bic_values <- sapply(models, bic_func)
  return(bic_values)
}

# Simulate and fit models
simulate_and_fit_models <- function(ni, m, beta, random_effects_var, i) {
  message("Starting simulation ", i)
  data <- generate_data(ni, m, beta, random_effects_var)
  models <- fit_models(data)
  
  bic_fitzmaurice_values <- calculate_bic(models, bic_fitzmaurice)
  bic_normal_values <- calculate_bic(models, bic_normal)
  bic_hybrid_values <- calculate_bic(models, bic_hybrid)
  
  selected_model_fitzmaurice <- names(which.min(bic_fitzmaurice_values))
  selected_model_normal <- names(which.min(bic_normal_values))
  selected_model_hybrid <- names(which.min(bic_hybrid_values))
  
  results_df <- data.frame(
    simulation = i,
    ni = ni,
    bic_fitzmaurice_full = bic_fitzmaurice_values["full"],
    bic_fitzmaurice_reduced1 = bic_fitzmaurice_values["reduced1"],
    bic_fitzmaurice_reduced2 = bic_fitzmaurice_values["reduced2"],
    bic_normal_full = bic_normal_values["full"],
    bic_normal_reduced1 = bic_normal_values["reduced1"],
    bic_normal_reduced2 = bic_normal_values["reduced2"],
    bic_hybrid_full = bic_hybrid_values["full"],
    bic_hybrid_reduced1 = bic_hybrid_values["reduced1"],
    bic_hybrid_reduced2 = bic_hybrid_values["reduced2"],
    selected_model_fitzmaurice = selected_model_fitzmaurice,
    correct_model_fitzmaurice = selected_model_fitzmaurice == "reduced2",
    selected_model_normal = selected_model_normal,
    correct_model_normal = selected_model_normal == "reduced2",
    selected_model_hybrid = selected_model_hybrid,
    correct_model_hybrid = selected_model_hybrid == "reduced2"
  )
  
  message("Ending simulation ", i)
  return(results_df)
}

```

```{r}
# Function to run multiple simulations
run_simulation <- function(num_simulations, ni, m, beta, random_effects_var, ncores = detectCores()) {
  cat("Running simulations...\n")
  results <- mclapply(1:num_simulations, function(i) {
    simulate_and_fit_models(ni, m, beta, random_effects_var, i)
  }, mc.cores = ncores)
  
  return(do.call(rbind, results))
}

# Modified function to run simulations for different subject numbers
run_simulations_for_subject_numbers <- function(subject_numbers, num_simulations, ni, beta, random_effects_var, ncores = detectCores()) {
  results_list <- list()
  
  for (m in subject_numbers) {
    cat(sprintf("\nRunning simulations for subject numbers = %d...\n", m))
    results <- run_simulation(num_simulations = num_simulations, ni = ni, m = m, beta = beta,random_effects_var = random_effects_var, ncores = ncores)
    results <- na.omit(results)
    results_list[[paste0("m_", m)]] <- results
  }
  
  return(results_list)
}

```



```{r, eval=FALSE}
# Parameters for the simulation
set.seed(123)
num_simulations <- 100
beta <- c(10, 10, 1, 1, 1)
random_effects_var <- c(1, 1)
subject_numbers <- c(10, 30, 50)
ni = 5

# Run simulations and save results
results <- run_simulations_for_subject_numbers(subject_numbers = subject_numbers, num_simulations = num_simulations, ni = ni, beta = beta, random_effects_var, ncores = 1) # defined ncores because mclapply does not work on Windows

saveRDS(results, file = "simulation_results_list.rds")

results %>% bind_rows(.id = "m") %>% group_by(m) %>% summarise(n = mean(correct_model_normal), f = mean(correct_model_fitzmaurice), h = mean(correct_model_hybrid))


results %>% bind_rows(.id = "m") %>% group_by(m) %>% count(selected_model_normal)
results %>% bind_rows(.id = "m") %>% group_by(m) %>% count(selected_model_fitzmaurice)
results %>% bind_rows(.id = "m") %>% group_by(m) %>% count(selected_model_hybrid)
```


```{r example, eval=FALSE}
## looking at an example
data <- generate_data(ni = ni, m=10, beta = beta, random_effects_var = random_effects_var)
data %>% ggplot(aes(x = time, y = y, group=group_id)) + geom_line() + theme_bw()

full = lmer(y ~ 0+ time + I(time^2) + x1 + x2 + x3  + (1 + time + I(time^2) || group_id), data = data, REML = FALSE)
full

bic_normal(full)
BIC(full)
# why are they different?
#they are the same now since we have the correct number of parameters 

```


```{r, fig.height=8}
results_list <- readRDS("simulation_results_list.rds")

# Initialize lists to store plots
violin_plots <- list()

for (name in names(results_list)) {
  all_results <- results_list[[name]]
  
  # Convert BIC columns to long format for plotting
  bics_long <- pivot_longer(all_results, cols = starts_with("bic_"), names_to = "BIC_definition_model", values_to = "BIC")
  
  # Split BIC_definition_model into BIC_definition and model_name
  bics_long <- bics_long %>%
    separate(BIC_definition_model, into = c("BIC_definition", "model_name"), sep = "_(?=[^_]+$)")
  
  # Filter for one BIC definition for an individual plot
  bic_def_example <- bics_long %>% filter(BIC_definition == "bic_normal")
  
  # Violin plot for BIC values (one definition)
  violin_plot <- ggplot(bic_def_example, aes(x = model_name, y = BIC, fill = model_name)) +
    geom_violin() +
    theme_minimal() +
    labs(title = paste("BIC Distribution for BIC Definition - bic_normal", name),
         x = "Model", y = "BIC Value") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.margin = margin(0, 0, 0, 0))
  
  violin_plots[[name]] <- violin_plot
}

# Combine all violin plots for individual BIC definitions using patchwork
combined_violin_plot <- wrap_plots(violin_plots, ncol = 1) & theme(plot.margin = margin(0, 0, 0, 0))

# Display combined plots for one BIC definition
print(combined_violin_plot)

# Now, create combined plots for all BIC definitions
for (name in names(results_list)) {
  all_results <- results_list[[name]]
  
  # Convert BIC columns to long format for plotting
  bics_long <- pivot_longer(all_results, cols = starts_with("bic_"), names_to = "BIC_definition_model", values_to = "BIC")
  
  # Split BIC_definition_model into BIC_definition and model_name
  bics_long <- bics_long %>%
    separate(BIC_definition_model, into = c("BIC_definition", "model_name"), sep = "_(?=[^_]+$)")
  
  # Violin plot for BIC values (all definitions)
  violin_plot <- ggplot(bics_long, aes(x = model_name, y = BIC, fill = model_name)) +
    geom_violin() +
    facet_wrap(~ BIC_definition) +
    theme_minimal() +
    labs(title = paste("BIC Distribution by True Model and Fitted Model -", name),
         x = "Model", y = "BIC Value") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.margin = margin(0, 0, 0, 0))
  
  violin_plots[[name]] <- violin_plot
}

# Combine all violin plots for all BIC definitions using patchwork
combined_violin_plot_all <- wrap_plots(violin_plots, ncol = 1) & theme(plot.margin = margin(0, 0, 0, 0))

# Display combined plots for all BIC definitions
print(combined_violin_plot_all)


```


```{r}
results_list <- readRDS("simulation_results_list.rds")

all_results <- results_list %>% bind_rows(.id = "ni")
row.names(all_results) <- NULL

selected_models_long <- pivot_longer(all_results, 
                                     cols =starts_with("selected_model_"), names_to = "BIC_definition", values_to = "selected_model") %>% 
  mutate(BIC_definition = factor(BIC_definition, 
                                 levels = c("selected_model_fitzmaurice", "selected_model_normal", "selected_model_hybrid"), 
                                 labels = c("BIC_f", "BIC_s","BIC_h")))

ggplot(selected_models_long, aes(x = BIC_definition, fill = selected_model)) +
    geom_bar() +  
    facet_wrap(~ ni) +
    theme_minimal() +
    labs(title = "Model Selection Proportions",
         x = "", y = "Proportion",
         fill = "Selected Model")



#### check REML, make plot to see data distribution, and check criteria implementation
#fixed criteria to include correct number of parameters 
```

